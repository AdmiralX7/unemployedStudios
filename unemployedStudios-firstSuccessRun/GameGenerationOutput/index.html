<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport" />
    <title>Code Quest: CS Student Journey</title>
    <style>
      body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Orbitron', sans-serif;
            background-color: #1a1a2e;
            color: #ffffff;
            touch-action: none; /* Prevent default touch actions */
        }
        .screen {
            display: none;
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }
        .screen.active {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .container {
            text-align: center;
            max-width: 600px;
            width: 90%;
        }
        button {
            background: linear-gradient(135deg, #283c86 0%, #45a247 100%);
            border: 2px solid #fff;
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            text-transform: uppercase;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            padding: 12px 30px;
            margin: 20px auto 0;
            display: block;
            width: 215.15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            background: linear-gradient(135deg, #45a247 0%, #283c86 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        #game-title {
            font-size: 2.5em;
            margin-bottom: 30px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            color: #e94560;
        }
        #game-controls {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(26, 26, 46, 0.8);
            padding: 10px 0;
            z-index: 101;
            display: none;
            text-align: center;
        }
        #game-controls button {
            display: inline-block;
            width: auto;
            padding: 8px 15px;
            margin: 0 5px;
            font-size: 14px;
        }
        #hud {
            position: fixed;
            top: 50px;
            left: 0;
            width: 100%;
            background-color: rgba(26, 26, 46, 0.8);
            color: #ffffff;
            padding: 10px;
            z-index: 100;
            display: none;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        #game-container {
            position: relative;
            width: 100%;
            height: calc(100% - 100px);
            overflow: hidden;
            background: url('assets/images/background.png') no-repeat center center;
            background-size: cover;
            border: 2px solid #e94560;
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(26, 26, 46, 0.3),
                rgba(15, 52, 96, 0.3)
            );
            pointer-events: none;
        }
        #game-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: radial-gradient(circle, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            animation: parallaxBG 10s linear infinite;
            pointer-events: none;
        }
        @keyframes gradientBG {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        @keyframes parallaxBG {
            0% {
                background-position: 0 0;
            }
            100% {
                background-position: 30px 30px;
            }
        }
        #gameCanvas {
            position: relative;
            z-index: 1;
            background: transparent !important;
        }
        #game-screen {
            background: none;
        }
        #instructions-screen {
            z-index: 200;
        }
        #instructions-screen.overlay {
            background: rgba(0, 0, 0, 0.8);
        }
        #instructions-screen .container {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }
        @media (max-width: 600px) {
            #game-title {
                font-size: 2em;
            }
            button {
                width: 80%;
                font-size: 16px;
            }
            #game-controls button {
                font-size: 12px;
                padding: 6px 12px;
            }
        }
        
        /* Default CSS extensions */
        .hud-container {
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            font-family: 'Orbitron', sans-serif;
        }
        
        .hud-item {
            background-color: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            margin: 0 5px;
        }
        
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        .fade-out {
            opacity: 0;
        }
        
        /* Game object styles */
        .player {
            background-color: #45a247;
            border: 2px solid #fff;
        }
        
        .enemy {
            background-color: #e94560;
            border: 2px solid #fff;
        }
        
        .collectible {
            background-color: #ffcc00;
            border: 2px solid #fff;
            border-radius: 50%;
        }
        
        .platform {
            background-color: #283c86;
            border: 1px solid #fff;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: none; /* Hidden by default, shown on mobile */
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 1000;
        }
        
        .d-pad {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .d-pad-row {
            display: flex;
            gap: 10px;
        }
        
        .mobile-button {
            width: 60px;
            height: 60px;
            background: rgba(40, 60, 134, 0.8);
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
            touch-action: none;
        }
        
        .mobile-button:active {
            background: rgba(69, 162, 71, 0.8);
        }
        
        .mobile-button.jump-btn {
            width: 80px;
            height: 80px;
            font-size: 16px;
            background: rgba(233, 69, 96, 0.8);
        }
        
        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
            
            #game-container {
                height: calc(100% - 180px); /* Adjust for mobile controls */
            }
        }

        /* Add glow effect to the ground */
        .ground-glow {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: linear-gradient(to top, 
                rgba(40, 60, 134, 0.4),
                rgba(40, 60, 134, 0.2),
                transparent
            );
            pointer-events: none;
        }
    </style>
  </head>
  <body>
    <div id="game-controls">
        <button id="game-menu-button">Menu</button>
        <button id="game-restart-button">Restart</button>
        <button id="game-instructions-button">Instructions</button>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div class="d-pad">
            <div class="d-pad-row">
                <div class="mobile-button" id="left-btn">←</div>
                <div class="mobile-button" id="right-btn">→</div>
            </div>
        </div>
        <div class="mobile-button jump-btn" id="jump-btn">JUMP</div>
    </div>
    
    <!-- Use HUD for Score, High Score, and Other Game Information -->
    <div id="hud"></div>

    <div id="start-menu-screen" class="active screen">
        <div class="container">
            <h1 id="game-title">Code Quest: CS Student Journey</h1>
            <button id="play-button">Play</button>
            <button id="settings-button">Settings</button>
            <button id="instructions-button">Instructions</button>
        </div>
    </div>

    <div id="settings-screen" class="screen">
        <div class="container">
            <h2>Settings</h2>
            <!-- Add settings options here -->
            <button id="settings-back-button">Back</button>
        </div>
    </div>

    <div id="instructions-screen" class="screen">
        <div class="container">
            <h2>Instructions</h2>
            <h3>How to Play:</h3>
            <ul>
                <li>Collect all the items to complete each level</li>
                <li>Avoid enemies to stay healthy</li>
                <li>Complete all levels to win the game</li>
            </ul>
            <h3>Controls:</h3>
            <ul>
                <li>Left/Right Arrows: Move the player</li>
                <li>Up Arrow or Space: Jump</li>
            </ul>
            <button id="instructions-back-button">Back</button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div id="game-container">
            <div class="ground-glow"></div>
        </div>
    </div>

    <div id="game-over-screen" class="screen">
        <div class="container">
            <h2>Game Over</h2>
            <div id="game-over-message">Thanks for playing!</div>
            <button id="play-again-button">Play Again</button>
            <button id="main-menu-button">Main Menu</button>
        </div>
    </div>
    
    <audio autoplay id="background-music" loop>
      <source src="assets/audio/university_music.mp3" type="audio/mpeg" />
    </audio>
    <audio id="start-game-sound">
      <source src="assets/audio/internship_music.mp3" type="audio/mpeg" />
    </audio>
    <audio id="jump-sound">
      <source src="assets/audio/jump_sound.mp3" type="audio/mpeg" />
    </audio>
    <audio id="collect-sound">
      <source src="assets/audio/collect_item_sound.mp3" type="audio/mpeg" />
    </audio>
    <audio id="hit-sound">
      <source src="assets/audio/enemy_defeat_sound.mp3" type="audio/mpeg" />
    </audio>
    <audio id="level-complete-sound">
      <source src="assets/audio/internship_music.mp3" type="audio/mpeg" />
    </audio>
    
    <!-- Game Scripts -->
    <script src="assets/js/audio_manager.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // Initialize audio manager
        const audioManager = new AudioManager();
        
        class GameUI {
          constructor() {
            this.startMenuScreen = document.getElementById('start-menu-screen');
            this.settingsScreen = document.getElementById('settings-screen');
            this.instructionsScreen = document.getElementById('instructions-screen');
            this.gameContainer = document.getElementById('game-screen');
            this.gameOverScreen = document.getElementById('game-over-screen');
            this.gameControls = document.getElementById('game-controls');
            this.hud = document.getElementById('hud');
            
            // Game state variables for UI
            this.score = 0;
            this.health = 100;
            this.currentLevel = 1;
          }
          
          swapToScreen(screen) {
            this.startMenuScreen.classList.remove('active');
            this.settingsScreen.classList.remove('active');
            this.instructionsScreen.classList.remove('active');
            this.gameContainer.classList.remove('active');
            this.gameOverScreen.classList.remove('active');
            screen.classList.add('active');			
            
            if (screen.id === 'game-screen') {
                this.hud.style.display = 'block';
                this.gameControls.style.display = 'block';
            } else {
                this.hud.style.display = 'none';
                this.gameControls.style.display = 'none';
            }
          }
          
          startGame() {
            const startGameSound = document.getElementById('start-game-sound');
            this.swapToScreen(this.gameContainer);
            startGameSound.play();
          }
          
          endGame() {
            const levelCompleteSound = document.getElementById('level-complete-sound');
            this.swapToScreen(this.gameOverScreen);
            if (levelCompleteSound) levelCompleteSound.play();
            
            const gameOverMessage = document.getElementById('game-over-message');
            if (gameOverMessage) {
                if (this.health <= 0) {
                    gameOverMessage.innerText = "Game Over! Your health reached zero.";
                } else {
                    gameOverMessage.innerText = "Congratulations! You completed the game!";
                }
            }
          }
          
          mainMenu() {
            this.swapToScreen(this.startMenuScreen);
          }
          
          playAgain() {
            this.swapToScreen(this.gameContainer);
          }
          
          settings() {
            this.swapToScreen(this.settingsScreen);
          }
          
          instructions() {
            this.swapToScreen(this.instructionsScreen);
          }
          
          updateHUD() {
              const hud = document.getElementById('hud');
              if (hud) {
                  hud.innerHTML = `
                      <div class="hud-container">
                          <div class="hud-item">Level: ${this.currentLevel}</div>
                          <div class="hud-item">Score: ${this.score}</div>
                          <div class="hud-item">Health: ${this.health}</div>
                      </div>
                  `;
              }
          }
          
          showMessage(message, duration = 3000) {
              const messageElement = document.createElement('div');
              messageElement.className = 'game-message';
              messageElement.textContent = message;
              document.getElementById('game-container').appendChild(messageElement);
              
              setTimeout(() => {
                  messageElement.classList.add('fade-out');
                  setTimeout(() => {
                      messageElement.remove();
                  }, 500);
              }, duration);
          }
        }

        class GameLogic {
          constructor() {
            // Player setup
            this.player = {
              x: 100,
              y: 450,
              width: 64,
              height: 64,
              speed: 5,
              jumpForce: -15, // Reduced from -20 for slower initial jump velocity
              velocityY: 0,
              isJumping: false,
              jumpCooldown: false,
              health: 100,
              score: 0,
              direction: 1, // 1 = right, -1 = left
              state: 'idle', // idle, running, jumping
              gender: 'male', // male or female
              animationFrame: 0,
              frameCount: 0,
              invulnerable: false,
              isFlashing: false
            };
            
            // Game world physics
            this.gravity = 0.5; // Reduced from 0.8 for slower falling
            this.groundLevel = 480;
            
            // Game state
            this.enemies = [];
            this.collectibles = [];
            this.gameObjects = [this.player];
            this.levels = [1, 2, 3];
            this.currentLevel = 1;
            
            // Initialize level
            this.loadLevel(this.currentLevel);
          }
          
          loadLevel(level) {
              console.log(`Loading level ${level}`);
              // Clear existing entities
              this.enemies = [];
              this.collectibles = [];
              
              // Create enemies based on level
              const enemyCount = level + 1;
              for (let i = 0; i < enemyCount; i++) {
                  const baseX = 200 + i * 150;
                  this.enemies.push({
                      x: baseX,
                      y: this.groundLevel - 64,
                      width: 64,
                      height: 64,
                      speed: 2 + level * 0.5,
                      direction: i % 2 === 0 ? 1 : -1,
                      // Base position for patterns
                      baseX: baseX,
                      baseY: this.groundLevel - 64,
                      // Level 2: Circular motion parameters
                      radius: level === 2 ? 40 : 0,
                      angle: i * (Math.PI / 2), // Starting angle
                      rotationSpeed: level === 2 ? 0.03 : 0,
                      // Level 3: Sinusoidal parameters
                      amplitude: level === 3 ? 50 : 0,
                      frequency: 0.02,
                      phase: i * Math.PI / 2
                  });
              }
              
              // Create collectibles based on level
              const collectibleCount = 5;
              for (let i = 0; i < collectibleCount; i++) {
                  this.collectibles.push({
                      x: 150 + i * 120,
                      y: 400 - level * 30,
                      width: 20,
                      height: 20,
                      collected: false
                  });
              }
              
              // Update game objects
              this.gameObjects = [this.player, ...this.enemies, ...this.collectibles];
              
              // Reset player position
              this.player.x = 100;
              this.player.y = 450;
              this.player.velocityY = 0;
              this.player.isJumping = false;
          }
          
          nextLevel() {
              if (this.currentLevel < this.levels.length) {
                  this.currentLevel++;
                  this.loadLevel(this.currentLevel);
                  return true;
              }
              return false;
          }
          
          handleInput(input) {
              // Handle key presses
              if (input.keysPressed['ArrowLeft']) {
                  this.player.x = Math.max(0, this.player.x - this.player.speed);
                  this.player.direction = -1;
                  this.player.state = 'running';
              }
              if (input.keysPressed['ArrowRight']) {
                  this.player.x = Math.min(800 - this.player.width, this.player.x + this.player.speed);
                  this.player.direction = 1;
                  this.player.state = 'running';
              }
              
              // Jump handling
              if ((input.keysPressed['ArrowUp'] || input.keysPressed[' '])) {
                  if (!this.player.isJumping && !this.player.jumpCooldown) {
                      console.log('Jump initiated');
                      this.player.velocityY = this.player.jumpForce;
                      this.player.isJumping = true;
                      this.player.state = 'jumping';
                      this.player.jumpCooldown = true;
                      
                      // Play jump sound
                      audioManager.playSound('jump');
                      
                      // Reset jump cooldown after a short delay
                      setTimeout(() => {
                          this.player.jumpCooldown = false;
                      }, 300);
                  }
              }
              
              // Set idle state if not moving horizontally and not jumping
              if (!input.keysPressed['ArrowLeft'] && !input.keysPressed['ArrowRight'] && !this.player.isJumping) {
                  this.player.state = 'idle';
              }
          }
          
          update(deltaTime) {
              // Apply gravity and update position
              if (this.player.isJumping || this.player.y < this.groundLevel - this.player.height) {
                  // Apply gravity
                  this.player.velocityY += this.gravity;
                  
                  // Update vertical position
                  this.player.y += this.player.velocityY;
                  
                  // Check for landing
                  if (this.player.y >= this.groundLevel - this.player.height) {
                      this.player.y = this.groundLevel - this.player.height;
                      this.player.velocityY = 0;
                      this.player.isJumping = false;
                      this.player.state = 'idle';
                  }
              }
              
              // Check collectible collisions
              this.collectibles = this.collectibles.filter(collectible => {
                  if (this.checkCollision(this.player, collectible)) {
                      // Play collect sound
                      audioManager.playSound('collect');
                      
                      // Increase score
                      this.player.score += 10;
                      
                      // Remove the collectible
                      return false;
                  }
                  return true;
              });
              
              // Enemy movement and collisions
              this.updateEnemies();
              
              // Update game objects
              this.gameObjects = [this.player, ...this.enemies, ...this.collectibles];
          }
          
          updateEnemies() {
              for (let enemy of this.enemies) {
                  if (this.currentLevel === 2) {
                      // Circular orbital motion for level 2
                      enemy.angle += enemy.rotationSpeed;
                      enemy.x = enemy.baseX + Math.cos(enemy.angle) * enemy.radius;
                      enemy.y = enemy.baseY + Math.sin(enemy.angle) * enemy.radius;
                      
                      // Update enemy direction based on movement
                      enemy.direction = Math.cos(enemy.angle) > 0 ? 1 : -1;
                  } else if (this.currentLevel === 3) {
                      // Sinusoidal motion for level 3
                      enemy.x += enemy.speed * enemy.direction;
                      enemy.phase += enemy.frequency;
                      enemy.y = enemy.baseY + Math.sin(enemy.phase) * enemy.amplitude;
                      
                      // Boundary check and direction change for level 3
                      if (enemy.x <= 0 || enemy.x >= 800 - enemy.width) {
                          enemy.direction *= -1;
                      }
                  } else {
                      // Regular horizontal motion for level 1
                      enemy.x += enemy.speed * enemy.direction;
                      
                      // Boundary check and direction change
                      if (enemy.x <= 0 || enemy.x >= 800 - enemy.width) {
                          enemy.direction *= -1;
                      }
                  }
                  
                  // Check for collision with player
                  if (this.checkCollision(this.player, enemy) && !this.player.invulnerable) {
                      // Apply damage to player
                      this.player.health -= 10;
                      
                      // Play hit sound
                      audioManager.playSound('enemyDefeat');
                      
                      // Make player temporarily invulnerable
                      this.player.invulnerable = true;
                      this.player.isFlashing = true;
                      
                      // Knockback effect
                      const knockbackForce = 8;
                      this.player.velocityY = -knockbackForce; // Knock upward
                      this.player.x += (enemy.x > this.player.x ? -knockbackForce : knockbackForce); // Knock horizontally
                      
                      // Reset invulnerability after a delay
                      setTimeout(() => {
                          this.player.invulnerable = false;
                          this.player.isFlashing = false;
                      }, 1500);
                  }
              }
          }
          
          checkCollision(objA, objB) {
              return objA.x < objB.x + objB.width &&
                     objA.x + objA.width > objB.x &&
                     objA.y < objB.y + objB.height &&
                     objA.y + objA.height > objB.y;
          }
        }
        
        class InputController {
          constructor() {
            this.keysPressed = {};
            this.initMobileControls();
          }
        
          init() {
            window.addEventListener('keydown', this.handleKeyDown.bind(this));
            window.addEventListener('keyup', this.handleKeyUp.bind(this));
          }
          
          initMobileControls() {
            // Helper function to handle touch events
            const handleTouch = (elementId, key, event) => {
                const button = document.getElementById(elementId);
                if (!button) return;
                
                const touchStart = () => {
                    this.keysPressed[key] = true;
                    event.preventDefault();
                };
                
                const touchEnd = () => {
                    delete this.keysPressed[key];
                    event.preventDefault();
                };
                
                button.addEventListener('touchstart', touchStart);
                button.addEventListener('touchend', touchEnd);
                button.addEventListener('touchcancel', touchEnd);
                
                // Also handle mouse events for testing in desktop browser
                button.addEventListener('mousedown', touchStart);
                button.addEventListener('mouseup', touchEnd);
                button.addEventListener('mouseleave', touchEnd);
            };
            
            // Initialize touch controls
            handleTouch('left-btn', 'ArrowLeft', new Event('touch'));
            handleTouch('right-btn', 'ArrowRight', new Event('touch'));
            handleTouch('jump-btn', ' ', new Event('touch')); // Space for jump
          }
        
          handleKeyDown(event) {
            this.keysPressed[event.key] = true;
          }
        
          handleKeyUp(event) {
            delete this.keysPressed[event.key];
          }
        }
        
        class Game {
          constructor() {
            this.ui = new GameUI();
            this.logic = new GameLogic();
            this.input = new InputController();
            this.lastFrameTime = 0;
            this.updateInterval = 1000 / 60; // 60 FPS
            this.done = false;
            this.isPaused = false;
            this.animationFrameId = null;
            
            // Set up game canvas
            this.canvas = document.createElement('canvas');
            this.canvas.width = 800;
            this.canvas.height = 600;
            this.canvas.id = 'gameCanvas';
            this.canvas.style.border = '2px solid #fff';
            this.ctx = this.canvas.getContext('2d');
            
            // Initialize game images
            this.gameImages = {
                enemy: new Image()
            };
            this.gameImages.enemy.src = 'assets/images/enemy.png';
            
            // Wait for images to load
            Promise.all([
                new Promise(resolve => this.gameImages.enemy.onload = resolve)
            ]).then(() => {
                console.log('All game images loaded successfully');
            }).catch(error => {
                console.error('Error loading game images:', error);
            });
          }
          
          prepareGame() {
            const gameContainer = document.getElementById('game-container');
            
            // Clear any existing content
            gameContainer.innerHTML = '';
            
            // Add the canvas to the game container
            gameContainer.appendChild(this.canvas);
            
            // Initialize input controller
            this.input.init();
            
            // Set up UI with game state
            this.updateUIState();
            
            // Connect DOM elements
            this.assignButtons();
          }
          
          startGame() {
            this.ui.startGame();
            
            // Reset game state
            this.logic = new GameLogic();
            
            // Update UI state
            this.updateUIState();
            
            // Start game loop
            if(this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
            }
            this.lastFrameTime = performance.now();
            this.isPaused = false;
            this.done = false;
            this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
          }
          
          updateUIState() {
            // Update UI with game state
            this.ui.score = this.logic.player.score;
            this.ui.health = this.logic.player.health;
            this.ui.currentLevel = this.logic.currentLevel;
            this.ui.updateHUD();
          }
          
          updateGame(deltaTime) {
            // Process input
            this.logic.handleInput(this.input);
            
            // Update physics multiple times for better accuracy
            const numPhysicsSteps = 3;
            const physicsTimeStep = deltaTime / numPhysicsSteps;
            
            for (let i = 0; i < numPhysicsSteps; i++) {
                this.logic.update(physicsTimeStep);
            }
            
            // Update UI
            this.updateUIState();
            
            // Check game conditions
            if (this.logic.player.health <= 0) {
                this.ui.endGame();
                this.resetGame();
            }
            
            // Check level completion
            if (this.logic.collectibles.length === 0) {
                const levelCompleteSound = document.getElementById('level-complete-sound');
                if (levelCompleteSound) levelCompleteSound.play();
                
                if (!this.logic.nextLevel()) {
                    // Game completed
                    this.ui.endGame();
                    this.resetGame();
                } else {
                    this.ui.showMessage(`Level ${this.logic.currentLevel} Complete!`, 2000);
                    this.updateUIState();
                }
            }
            
            // Render game
            this.render();
          }
          
          render() {
              // Clear canvas with transparency
              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
              
              // Draw semi-transparent ground
              this.ctx.fillStyle = 'rgba(40, 60, 134, 0.5)';
              this.ctx.fillRect(0, this.logic.groundLevel, this.canvas.width, this.canvas.height - this.logic.groundLevel);
              
              // Add ground border
              this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
              this.ctx.lineWidth = 2;
              this.ctx.beginPath();
              this.ctx.moveTo(0, this.logic.groundLevel);
              this.ctx.lineTo(this.canvas.width, this.logic.groundLevel);
              this.ctx.stroke();
              
              // Draw player
              this.drawPlayer();
              
              // Draw enemies
              for (let enemy of this.logic.enemies) {
                  // Draw enemy glow effect
                  const gradient = this.ctx.createRadialGradient(
                      enemy.x + enemy.width/2,
                      enemy.y + enemy.height/2,
                      0,
                      enemy.x + enemy.width/2,
                      enemy.y + enemy.height/2,
                      enemy.width
                  );
                  gradient.addColorStop(0, 'rgba(233, 69, 96, 0.4)');
                  gradient.addColorStop(1, 'rgba(233, 69, 96, 0)');
                  this.ctx.fillStyle = gradient;
                  this.ctx.beginPath();
                  this.ctx.arc(
                      enemy.x + enemy.width/2,
                      enemy.y + enemy.height/2,
                      enemy.width/1.5,
                      0,
                      Math.PI * 2
                  );
                  this.ctx.fill();
                  
                  // Draw enemy image
                  if (this.gameImages.enemy.complete) {
                      this.ctx.save();
                      
                      // If enemy is moving left, flip the image
                      if (enemy.direction < 0) {
                          this.ctx.translate(enemy.x + enemy.width, enemy.y);
                          this.ctx.scale(-1, 1);
                          this.ctx.drawImage(this.gameImages.enemy, 0, 0, enemy.width, enemy.height);
                      } else {
                          this.ctx.drawImage(this.gameImages.enemy, enemy.x, enemy.y, enemy.width, enemy.height);
                      }
                      
                      this.ctx.restore();
                  }
              }
              
              // Draw collectibles with enhanced visibility
              for (let collectible of this.logic.collectibles) {
                  // Draw outer glow
                  const gradient = this.ctx.createRadialGradient(
                      collectible.x + collectible.width/2,
                      collectible.y + collectible.height/2,
                      0,
                      collectible.x + collectible.width/2,
                      collectible.y + collectible.height/2,
                      collectible.width * 2
                  );
                  gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                  gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                  this.ctx.fillStyle = gradient;
                  this.ctx.beginPath();
                  this.ctx.arc(
                      collectible.x + collectible.width/2,
                      collectible.y + collectible.height/2,
                      collectible.width * 2,
                      0,
                      Math.PI*2
                  );
                  this.ctx.fill();
                  
                  // Draw coin with border
                  this.ctx.fillStyle = '#ffcc00';
                  this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                  this.ctx.lineWidth = 2;
                  this.ctx.beginPath();
                  this.ctx.arc(
                      collectible.x + collectible.width/2,
                      collectible.y + collectible.height/2,
                      collectible.width/2,
                      0,
                      Math.PI*2
                  );
                  this.ctx.fill();
                  this.ctx.stroke();
                  
                  // Add shine effect
                  this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                  this.ctx.lineWidth = 3;
                  this.ctx.beginPath();
                  this.ctx.arc(
                      collectible.x + collectible.width/2,
                      collectible.y + collectible.height/2,
                      collectible.width/3,
                      0,
                      Math.PI/2
                  );
                  this.ctx.stroke();
              }
              
              // Draw level info with enhanced visibility
              this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
              this.ctx.shadowBlur = 10;
              this.ctx.fillStyle = '#ffffff';
              this.ctx.font = 'bold 20px Orbitron';
              this.ctx.fillText(`Level ${this.logic.currentLevel}`, 10, 30);
              
              // Reset shadow
              this.ctx.shadowBlur = 0;
              this.ctx.shadowColor = 'transparent';
          }
          
          drawPlayer() {
              const player = this.logic.player;
              
              // Skip drawing if player is flashing (for damage feedback)
              if (player.isFlashing && Math.floor(Date.now() / 100) % 2 === 0) {
                  return;
              }
              
              // Initialize player images if not already done
              if (!this.playerImages) {
                  this.playerImages = {
                      idle_male: new Image(),
                      idle_female: new Image(),
                      running: new Image(),
                      jumping: new Image()
                  };
                  
                  // Set image sources from our assets
                  this.playerImages.idle_male.src = 'assets/images/student_idle_male.png';
                  this.playerImages.idle_female.src = 'assets/images/student_idle_female.png';
                  this.playerImages.running.src = 'assets/images/student_running.png';
                  this.playerImages.jumping.src = 'assets/images/student_jumping.png';
                  
                  // Draw placeholder while images load
                  this.ctx.fillStyle = '#45a247';
                  this.ctx.fillRect(player.x, player.y, player.width, player.height);
                  return;
              }
              
              // Choose the right sprite based on player state and gender
              let image;
              if (player.state === 'idle') {
                  image = player.gender === 'female' ? this.playerImages.idle_female : this.playerImages.idle_male;
              } else if (player.state === 'running') {
                  image = this.playerImages.running;
              } else if (player.state === 'jumping') {
                  image = this.playerImages.jumping;
              }
              
              // Draw placeholder if image isn't loaded yet
              if (!image || !image.complete) {
                  this.ctx.fillStyle = '#45a247';
                  this.ctx.fillRect(player.x, player.y, player.width, player.height);
                  return;
              }
              
              // Apply direction and draw the sprite
              this.ctx.save();
              if (player.direction === -1) {
                  // Flip horizontally for left direction
                  this.ctx.translate(player.x + player.width, player.y);
                  this.ctx.scale(-1, 1);
                  this.ctx.drawImage(image, 0, 0, player.width, player.height);
              } else {
                  this.ctx.drawImage(image, player.x, player.y, player.width, player.height);
              }
              this.ctx.restore();
              
              // Draw health bar above player
              const healthBarWidth = player.width;
              const healthBarHeight = 5;
              const healthPercentage = player.health / 100;
              
              // Health bar background
              this.ctx.fillStyle = '#ff0000';
              this.ctx.fillRect(
                  player.x,
                  player.y - healthBarHeight - 5,
                  healthBarWidth,
                  healthBarHeight
              );
              
              // Health bar fill
              this.ctx.fillStyle = '#00ff00';
              this.ctx.fillRect(
                  player.x,
                  player.y - healthBarHeight - 5,
                  healthBarWidth * healthPercentage,
                  healthBarHeight
              );
          }
          
          resetGame() {
            this.done = true;
            this.isPaused = false;
            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }
          }
          
          pause() {
            this.isPaused = true;
            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }
          }
          
          resume() {
            if (this.isPaused) {
                this.isPaused = false;
                this.lastFrameTime = performance.now();
                this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
            }
          }
          
          gameLoop(timestamp) {
              if (this.done || this.isPaused) return;
              
              // Calculate delta time
              if (!this.lastFrameTime) {
                  this.lastFrameTime = timestamp;
              }
              const deltaTime = timestamp - this.lastFrameTime;
              this.lastFrameTime = timestamp;
              
              // Update game state
              this.updateGame(deltaTime);
              
              // Request next frame
              this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
          }
          
          assignButtons() {
            const playButton = document.getElementById('play-button');
            const settingsButton = document.getElementById('settings-button');
            const instructionsButton = document.getElementById('instructions-button');
            const playAgainButton = document.getElementById('play-again-button');
            const settingsBackButton = document.getElementById('settings-back-button');
            const instructionsBackButton = document.getElementById('instructions-back-button');
            const gameMenuButton = document.getElementById('game-menu-button');
            const gameRestartButton = document.getElementById('game-restart-button');
            const gameInstructionsButton = document.getElementById('game-instructions-button');
            const mainMenuButton = document.getElementById('main-menu-button');
    
            playButton.addEventListener('click', this.startGame.bind(this));
            
            if (settingsButton) {
                settingsButton.addEventListener('click', this.ui.settings.bind(this.ui));
            }
            
            if (instructionsButton) {
                instructionsButton.addEventListener('click', this.ui.instructions.bind(this.ui));
            }
            
            if (playAgainButton) {
                playAgainButton.addEventListener('click', this.startGame.bind(this));
            }
            
            if (settingsBackButton) {
                settingsBackButton.addEventListener('click', this.ui.mainMenu.bind(this.ui));
            }
            
            if (instructionsBackButton) {
                instructionsBackButton.addEventListener('click', this.ui.mainMenu.bind(this.ui));
            }
            
            if (mainMenuButton) {
                mainMenuButton.addEventListener('click', this.ui.mainMenu.bind(this.ui));
            }
            
            if (gameMenuButton) {
                gameMenuButton.addEventListener('click', this.ui.mainMenu.bind(this.ui));
            }
            
            if (gameRestartButton) {
                gameRestartButton.addEventListener('click', this.startGame.bind(this));
            }
            
            if (gameInstructionsButton) {
                gameInstructionsButton.addEventListener('click', () => {
                    this.pause();
                    this.ui.swapToScreen(this.ui.instructionsScreen);
                    
                    const handleBack = () => {
                        this.ui.swapToScreen(this.ui.gameContainer);
                        this.resume();
                        instructionsBackButton.removeEventListener('click', handleBack);
                    };
                    
                    instructionsBackButton.addEventListener('click', handleBack);
                });
            }
          }
        }
        
        // Initialize the game
        const game = new Game();
        game.prepareGame();
        
        // Add viewport meta for mobile
        if (!document.querySelector('meta[name="viewport"]')) {
            const meta = document.createElement('meta');
            meta.name = 'viewport';
            meta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
            document.head.appendChild(meta);
        }
      });
    </script>
  </body>
</html> 